package main

import (
	"encoding/json"
	"fmt"
	"github.com/NYTimes/gziphandler"
	"github.com/gorilla/mux"
	log "github.com/sirupsen/logrus"
	"html/template"
	"net/http"
	"time"
)

const REQUEST_SIZE = "3000"

type AutoGenerated struct {
	Embedded struct {
		Spectraevidences []struct {
			Usi string `json:"usi"`
			// UsiLink    template.URL
			UsiLink    template.URL
			NumPeaks   int `json:"numPeaks"`
			Attributes []struct {
				Type      string `json:"@type"`
				CvLabel   string `json:"cvLabel"`
				Accession string `json:"accession"`
				Name      string `json:"name"`
				Value     string `json:"value"`
			} `json:"attributes"`
			PeptideSequence string  `json:"peptideSequence"`
			Charge          int     `json:"charge"`
			PrecursorMZ     float64 `json:"precursorMZ"`
			Valid           bool    `json:"valid"`
			Decoy           bool    `json:"decoy"`
			Links           struct {
				Self struct {
					Href string `json:"href"`
				} `json:"self"`
			} `json:"_links"`
		} `json:"spectraevidences"`
	} `json:"_embedded"`
	Links struct {
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
		Next struct {
			Href string `json:"href"`
		} `json:"next"`
		Previous struct {
			Href string `json:"href"`
		} `json:"previous"`
		First struct {
			Href string `json:"href"`
		} `json:"first"`
		Last struct {
			Href string `json:"href"`
		} `json:"last"`
	} `json:"_links"`
	Page struct {
		Size          int `json:"size"`
		TotalElements int `json:"totalElements"`
		TotalPages    int `json:"totalPages"`
		Number        int `json:"number"`
	} `json:"page"`
}

func RequestBasic(url string) (AutoGenerated, error) {
	var cResp AutoGenerated
	//We make HTTP request using the Get function
	//	resp, err := http.Get(url)
	client := http.Client{
		Timeout: 50 * time.Second,
	}
	resp, err := client.Get(url)
	if err != nil {
		log.Fatal("ooopsss an error occurred, please try again")
		return cResp, err
	}
	defer resp.Body.Close()
	//Create a variable of the same type as our model
	//Decode the data
	if err := json.NewDecoder(resp.Body).Decode(&cResp); err != nil {
		log.Fatal("ooopsss! an error occurred while json, please try again")
		return cResp, err
	}
	log.Info(cResp.Page.TotalPages)
	for i, _ := range cResp.Embedded.Spectraevidences {
		//		cResp.Embedded.Spectraevidences[i].UsiLink = template.URL("?usi=mzspec:PXD015890:18May18_Olson_WT2.raw%20(F001551).mzid_18May18_Olson_WT2.raw_(F001551).MGF:index:6913:AEAEAQAEELSFPR/2&amp;usi_origin=pride")
		cResp.Embedded.Spectraevidences[i].UsiLink = template.URL("https://www.proteomicsdb.org/use/?usi=" + cResp.Embedded.Spectraevidences[i].Usi)
	}

	return cResp, nil
}
func RequestPxd(pxd string) (AutoGenerated, error) {

	// https://stackoverflow.com/questions/44800093/go-rendering-url-rowquery-string-in-a-template-different-behaviours

	// url := "https://www.ebi.ac.uk/pride/ws/archive/v2/spectra?projectAccession=" + pxd + "&pageSize=1"
	url := "https://www.ebi.ac.uk/pride/ws/archive/v2/spectra?projectAccession=" + pxd + "&pageSize=" + REQUEST_SIZE
	return RequestBasic(url)
}

func RequestPxdSequence(sequence string) (AutoGenerated, error) {

	// https://stackoverflow.com/questions/44800093/go-rendering-url-rowquery-string-in-a-template-different-behaviours

	// url := "https://www.ebi.ac.uk/pride/ws/archive/v2/spectra?projectAccession=" + pxd + "&pageSize=1"
	url := "https://www.ebi.ac.uk/pride/ws/archive/v2/spectra?peptideSequence=" + sequence + "&pageSize=" + REQUEST_SIZE
	return RequestBasic(url)
}
func RequestPxdModifiedSequence(modifiedSequence string) (AutoGenerated, error) {

	url := "https://www.ebi.ac.uk/pride/ws/archive/v2/spectra?modifiedSequence=" + modifiedSequence + "&pageSize=" + REQUEST_SIZE
	return RequestBasic(url)
}

func page_1(w http.ResponseWriter, r *http.Request) {
	data, err := RequestPxd("PXD015890")
	//	fmt.Printf("%+v\n", data.Embedded)
	fmt.Printf("1\n")
	if err != nil {
		log.Fatal("ooopsss an error occurred, please try again")
	}
	// tmpl, _ := template.ParseFiles("..templates/pxd.template")
	tmpl, _ := template.ParseFiles("./pxd.template")
	tmpl.Execute(w, data.Embedded)
}
func pxd_handle(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	fmt.Printf("%+v\n", vars)
	data, err := RequestPxd(vars["id"])
	//	fmt.Printf("%+v\n", data.Embedded)
	log.Printf("1\n")
	if err != nil {
		log.Fatal("ooopsss an error occurred, please try again")
	}
	// tmpl, _ := template.ParseFiles("..templates/pxd.template")
	tmpl, _ := template.ParseFiles("./pxd.template")
	tmpl.Execute(w, data.Embedded)
}
func pxd_handle_peptide(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	fmt.Printf("%+v\n", vars)
	data, err := RequestPxdSequence(vars["sequence"])
	//	fmt.Printf("%+v\n", data.Embedded)
	fmt.Printf("1\n")
	if err != nil {
		log.Fatal("ooopsss an error occurred, please try again")
	}
	// tmpl, _ := template.ParseFiles("..templates/pxd.template")
	tmpl, _ := template.ParseFiles("./pxd.template")
	tmpl.Execute(w, data.Embedded)
}
func pxd_handle_modified_sequence(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	fmt.Printf("%+v\n", vars)
	data, err := RequestPxdModifiedSequence(vars["modifiedSequence"])
	//	fmt.Printf("%+v\n", data.Embedded)
	fmt.Printf("3\n")
	if err != nil {
		log.Fatal("ooopsss an error occurred, please try again")
	}
	// tmpl, _ := template.ParseFiles("..templates/pxd.template")
	tmpl, _ := template.ParseFiles("./pxd.template")
	tmpl.Execute(w, data.Embedded)
}

func main() {
	logger := log.New()
	if true {
		logger.Level = log.InfoLevel
	} else {
		logger.Level = log.PanicLevel
	}
	//	logger.Formatter = &logrus.JSONFormatter{}

	withGz := gziphandler.GzipHandler(http.HandlerFunc(page_1))
	r := mux.NewRouter()

	// 	r.HandleFunc("/pxd/", ArticlesCategoryHandler)
	r.HandleFunc("/pxd/{id}", pxd_handle)
	r.HandleFunc("/peptide/{sequence}", pxd_handle_peptide)
	r.HandleFunc("/modifiedPeptide/{modifiedSequence}", pxd_handle_modified_sequence)

	// RequestPxd("PXD015890")
	// http.HandleFunc("/table", withGz)

	r.Handle("/table", withGz)
	// http.ListenAndServe(":8090", nil)
	log.Fatal(http.ListenAndServe(":8090", r))

	//	RequestPxd("PXD005011")
}
