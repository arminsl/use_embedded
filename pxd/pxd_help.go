package pxd

import (
	"bytes"
	"fmt"
	"github.com/bakins/logrus-middleware"
	"github.com/rakyll/statik/fs"
	"github.com/sirupsen/logrus"
	"github.com/spf13/pflag"
	"io/ioutil"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"
)

type AutoGenerated struct {
	Embedded struct {
		Spectraevidences []struct {
			Usi        string `json:"usi"`
			NumPeaks   int    `json:"numPeaks"`
			Attributes []struct {
				Type      string `json:"@type"`
				CvLabel   string `json:"cvLabel"`
				Accession string `json:"accession"`
				Name      string `json:"name"`
				Value     string `json:"value"`
			} `json:"attributes"`
			PeptideSequence string  `json:"peptideSequence"`
			Charge          int     `json:"charge"`
			PrecursorMZ     float64 `json:"precursorMZ"`
			Valid           bool    `json:"valid"`
			Decoy           bool    `json:"decoy"`
			Links           struct {
				Self struct {
					Href string `json:"href"`
				} `json:"self"`
			} `json:"_links"`
		} `json:"spectraevidences"`
	} `json:"_embedded"`
	Links struct {
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
		Next struct {
			Href string `json:"href"`
		} `json:"next"`
		Previous struct {
			Href string `json:"href"`
		} `json:"previous"`
		First struct {
			Href string `json:"href"`
		} `json:"first"`
		Last struct {
			Href string `json:"href"`
		} `json:"last"`
	} `json:"_links"`
	Page struct {
		Size          int `json:"size"`
		TotalElements int `json:"totalElements"`
		TotalPages    int `json:"totalPages"`
		Number        int `json:"number"`
	} `json:"page"`
}

func RequestPxd(string pxd) {
	url := "https://www.ebi.ac.uk/pride/ws/archive/v2/spectra?projectAccession=" + pxd
	//We make HTTP request using the Get function
	resp, err := http.Get(URL)
	if err != nil {
		log.Fatal("ooopsss an error occurred, please try again")
	}
	defer resp.Body.Close()
	//Create a variable of the same type as our model
	var cResp AutoGenerated
	//Decode the data
	if err := json.NewDecoder(resp.Body).Decode(&cResp); err != nil {
		log.Fatal("ooopsss! an error occurred, please try again")
	}
	fmt.Printf("%+v\n", cResp)
}

func Request() {
	var pxd = "PXD015890"
	url := "https://www.ebi.ac.uk/pride/ws/archive/v2/spectra?projectAccession=" + pxd

	fmt.Println(url)

	proxyReq, err := http.NewRequest(req.Method, url, bytes.NewReader(body))

	// We may want to filter some headers, otherwise we could just use a shallow copy
	// proxyReq.Header = req.Header
	proxyReq.Header = make(http.Header)
	for h, val := range req.Header {
		proxyReq.Header[h] = val
	}
	client := &http.Client{
		Timeout: 15 * time.Second}
	resp, err := client.Do(proxyReq)
	fmt.Println(resp)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadGateway)
		return
	}
	defer resp.Body.Close()
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadGateway)
		return
	}

}
func main() {
	RequestPxd("PXD015890")
}
